// 문제
/* 1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.

소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.
(1은 소수가 아닙니다.)
 */

//[풀이 1]
// 1부터 n 까지의 각 수를 반복하며 소수인지 판별
// ... 2부터 각 수의 제곱근 까지 비교하여 나누어 떨어지지 않을 경우 카운트를 추가
// 2중 for문이라 그런지 시간 초과가 났다 흑 ㅠ
function solution1(n) {
  // 입력 : 2 이상 자연수 n
  // 출력 : 1과 n 사이의 소수의 갯수

  let cnt = 0;

  for (let i = 1; i <= n; i++) {
    let flag = true;
    if (i === 1) flag = false;
    for (let j = 2; j <= Math.sqrt(i); j++) {
      if (i % j === 0) flag = false;
    }
    if (flag) cnt++;
  }
  return cnt;
}

// console.log(solution1(10));

//[풀이 2]
// 에라토스테네스의 체 풀이
// ... 소수를 대량으로 빠르고 정확하게 구하는 방법
// ... 특정 범위가 주어지고, 해당 범위 내의 소수의 갯수를 구할 때 사용하면 유용하다.
// ... 소수를 판별할 범위 만큼 배열을 만들고 값을 할당한 뒤, 조건에 맞게 하나씩 지우는 방법
// ... 자기 자신을 제외한 자신의 배수는 소수가 아님을 이용한 방법이다.
function solution2(n) {
  // 입력 : 2 이상 자연수 n
  // 출력 : 1과 n 사이의 소수의 갯수
  let cnt = 0;
  let arr = new Array().fill(0);

  // 2부터 시작하여 범위까지 반복하고, 그 값을 배열에 추가한다.
  // 소수는 2부터 시작하기 때문에, i도 2부터 시작한다.
  for (let i = 2; i <= n; i++) {
    arr[i] = i;
  }

  // 2부터 범위까지 반복하면서 배열을 순회한다.
  for (let i = 2; i <= n; i++) {
    // 현재 탐색중인 배열이 이미 0 (지워진 값) 이면 건너뛴다.
    if (arr[i] === 0) continue;

    // 만약 존재하는 값이라면, 해당 수의 배수부터 출발하여 n의 범위까지,
    // 현재 수(i)의 배수만 방문하여 초기화한다.
    for (let j = 2 * i; j <= n; j += i) {
      arr[j] = 0;
    }
  }

  // 다시 배열로 돌아와서, 해당 배열의 값이 0이 아니면 소수이므로 카운트를 증감한다.
  for (let num of arr) {
    if (num) cnt++;
  }
  return cnt;
}

console.log(solution2(10));

// 느낀 점
// 소수 문제를 풀 때 간혹 시간초과가 나면 에라토스테네스의 체를 사용해 푸는 것은 알고 있었는데
// 개념이 어려울 것 같아서 지금까진 제대로 못본 것 같다.
// 하나씩 풀면서 살펴보니 그렇게 어렵진 않은 것 같다.(응용하면 어려울 수도)
// 에라토스테네스의 체를 활용해서 풀 수 있는 다른 문제 : https://www.acmicpc.net/problem/4948
